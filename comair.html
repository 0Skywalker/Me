<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" type='text/css' href="./css/research.css">
  <link href="https://fonts.googleapis.com/css?family=Old+Standard+TT|PT+Serif" rel="stylesheet">
  <link rel="shortcut icon" href="./assets/images/favicon_192.png" type="image/x-icon">
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111325110-1"></script>
  <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date());gtag('config','UA-111325110-1');</script>
  <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1.0, maximum-scale=2.0, minimum-scale=1.0">
  <meta name="Description" content="This is a website hosted on github and developed by Alejandro Chávez Gómez.">
  <meta charset="utf-8">
  <title>Project | COMAIR</title>
</head>
  <body>

  <section class="page-wrap">
    <header>
      <p><b>CYBER SECURITY</b> (AIR GAPPING ATTACKS)</p>
    </header>

    <section class="title">
      <p class="title green"><b>COMMANDS IN THE AIR: <span class="black">ATAQUES A SISTEMAS AIR GAPPING</b></span></p>
      <hr class="line-short">
    </section>

    <section class="cover">
      <p class="author"><b>Chávez G. Alejandro</b></p>
      <img class="responsive" src="./assets/images/cmds.jpg" alt="Commands">
    </section>

    <section class="content">
      <p class="header"><b>INTRODUCCIÓN</b></p>
      <p>
        Commands in the Air o COMAIR, es el nombre que recibe esta investigación, la cual pretende demostrar e identificar técnicas de ataques a sistemas Air Gapping, con el objetivo de protegerlos contra posibles intrusiones de este tipo en el futuro.<br><br>Este documento expone la primer etapa de esta investigación que aborda la seguridad de los sistemas Air Gapping. En esta fase se expone una técnica ofensiva a este tipo de sistemas utilizando como vector de ataque los SSID (Service Set Identifier) que son identificados por las interfaces de red inalámbricas. En fases posteriores a la investigación, se espera aprovechar otros vectores de ataque, como por ejemplo, las ondas electromagnéticas que emiten algunos de los componentes de los computadores, con el fin de transmitir la información recabada a un receptor, o bien, utilizar señales de luz, señales acústicas, entre otros medios.<br><br>
      </p>

      <p class="header"><b>METODOLOGÍA</b></p>
      <p>
        Lo siguiente son los pasos que se utilizaron para demostrar dicha técnica de ataque, basada en los SSIDs capturados por las tarjetas de red inalámbricas:<br><br>
      </p>

      <p class="sub-header"><i>A. Definición de la idea</i></p>
      <p>
        Se pretende desarrollar un programa como prueba de concepto a lo largo de toda la investigación, que atienda a las peticiones que le son solicitadas a través de los SSIDs que son captados por la interfaz de red inalámbrica del equipo comprometido. Estas solicitudes son instrucciones que el programa reconoce y ejecuta en el sistema operativo huésped.<br>
      </p>

      <p>
        Según el contexto en el que se esté corriendo el programa, serán los privilegios que tendrán las instrucciones al ser ejecutadas por el sistema operativo. Las instrucciones pueden ser mostrar un mensaje en pantalla o abrir alguna página en el navegador, hasta grabar audio, video o ambos y subir las grabaciones a un servidor FTP, entre otras muchas posibilidades.<br><br>
        En el esquema anterior, se muestra el ejemplo de un equipo infectado con el malware y un SSID malicioso que contiene una instrucción, que al ser debidamente procesada por el malware, será ejecutada por el sistema operativo, abriendo la página de www.google.com en el navegador por defecto.<br><br>
      </p>

      <p class="sub-header"><i>B. Análisis del programa</i></p>
      <p>
        Al ser la primera fase, el programa tiene ciertas limitantes, por ejemplo:<br>
        <ul>
          <li>Solo funciona bajo sistemas operativos Windows.</li>
          <li>No permanece oculto para el usuario.</li>
          <li>Solo ejecuta comandos que sean entendidos por la terminal de Windows. Es decir, no incorpora la funcionalidad de mostrar mensajes en pantalla, grabar audio, vídeo o alguna otra característica.</li>
          <li>No cuenta con la capacidad de ejecutar instrucciones que usen más de una línea.</li>
          <li>Las instrucciones son ejecutadas con los privilegios que tenga el usuario en turno.</li>
        </ul>
        A continuación se describen los módulos y funciones con los que cuenta el programa en esta primer etapa:<br>
        <ul>
          <li class="green size18"><b>Main</b></li>
          <p>Este es el archivo principal. Desde este archivo se hacen las llamadas a los demás módulos.</p>
        </ul>

        <ul>
          <li class="green size18"><b>mod_wifi</b></li>
          <p>Este módulo es responsable de manejar los datos capturados por la interfaz de red inalámbrica. En la siguiente tabla se muestran y describen las funciones contenidas en este módulo.</p>
        </ul>
        <br>
        <table>
          <tr class="text-center">
            <td colspan="3">TABLA I<br>Módulo de Wi-Fi</td>
          </tr>
          <tr>
            <td class="text-left">Nombre</td>
            <td class="text-left">Argumentos</td>
            <td class="text-center">Descripción</td>
          </tr>
          <tr>
            <td><i>scan</i></td>
            <td>Ninguno</td>
            <td>
              Muestra una lista de los SSIDs de las redes inalámbricas que se encuentran dentro del rango de cobertura de la tarjeta de red inalámbrica.
            </td>
          </tr>
          <tr>
            <td>executeCommand</td>
            <td>int, char[]</td>
            <td>Limpia la instrucción y ejecuta el comando capturado con la función scan(). Recibe como parámetros un número (INT) que determina el tipo de instrucción y un arreglo (CHAR) con dicha instrucción.</td>
          </tr>
        </table>
      </p>
      <br>

      <p class="sub-header"><i>C. Desarrollo del programa</i></p>
      <p>
        El ciclo del programa es el siguiente: Se ejecuta la función principal, la cual manda a llamar a la función scan del módulo de Wi-Fi mod_wifi cada 10,000 milisegundos.<br><br>
        La función scan utiliza las librerías de windows.h, wlanapi.h, objbase.h y wtypes.h para usar la interfaz de red inalámbrica disponible, lanzar un escaneo y así enlistar los nombres (SSID) de puntos de acceso encontrados dentro del rango de cobertura de la tarjeta. Conforme va enlistando los nombres, va buscando las siguientes cadenas de caracteres: MSGS$, SHOT$, PICT$ y CMDS$, con el propósito de clasificar dicha instrucción y llamar a la función executeCommand, quien se encarga de limpiar la instrucción, removiendo los primeros 5 caracteres que sirven como identificador para la clasificación, y después procede a ejecutarla en el sistema operativo.<br><br>
        El desarrollo del programa sigue un esquema modular, en donde cada tarea específica que se pretende realizar, será un módulo.<br><br>
        Se utilizó el entorno de desarrollo integrado (IDE) de Visual Studio Community Edition con licencia vigente de estudiante, por contar con numerosas herramientas para la rápida y eficiente codificación de programas, así como avanzadas herramientas de depuración.<br><br>
        El lenguaje de programación utilizado fue C++ por su potencia en comparación con otros lenguajes. El compilador usado fue MSBuild.<br><br>
        El tamaño final del archivo es de 62.0 KB.<br><br>
      </p>


      <p class="header"><b>CONCLUSIÓN</b></p>
      <p>
           Se ha demostrado que tener un equipo aislado con interfaz de red inalámbrica puede llegar a ser igual de peligroso que estar conectado a internet. Existen otras técnicas en las que es posible lograr una exfiltración de datos exitosa sin levantar sospechas, por ejemplo, utilizando los incrementos y decrementos en la temperatura de un equipo, o bien manipulando la señal GSM que capta la antena de un teléfono, empleando un firmware instalado en el equipo infectado para utilizar su hardware como una antena GSM, entre otros métodos.<br><br>
           Sin duda el eslabón más débil siempre será el usuario y por ello es necesario que en todas las organizaciones existan reglas y políticas de seguridad que se actualicen y adapten constantemente a las nuevas amenazas informáticas que van surgiendo a la orden del día, para evitar futuros ciber ataques.<br><br>
           En las siguientes etapas de la investigación se espera ampliar la compatibilidad con demás sistemas operativos, incorporar nuevas funcionalidades y añadir nuevos vectores de ataque.<br><br>
      </p>

      <p class="header"><b>REFERENCIAS</b></p>
      <p>
        [1] MSDN Microsoft, “WlanGetAvailableNetworkList function” Wireless Networking, Mar. 11, 2018. [Online].
        Available: https://msdn.microsoft.com/en-us/library/ms706749(VS.85).aspx<br><br>
      </p>
      <p>
        <img class="profile" align="right" hspace="10" vspace="5" src="./assets/images/profile.png" alt="Me">
        <b>Chávez G. Alejandro</b> nació en Tijuana, Baja California, BC, México en 1995. Es estudiante de 8vo semestre de la carrera de ingeniería en sistemas computacionales con especialidad en bases de datos, en el Instituto Tecnológico de Tijuana desde el año 2014.<br><br>
        Ha trabajado y creado proyectos que involucran inteligencia artificial, visión por computador, ciberseguridad, big data, UX/UI y aplicaciones para entornos de escritorio y móviles. Algunos de los proyectos que ha desarrollado son una librería de componentes que siguen los lineamientos de Material Design creados por Google, para el lenguaje de programación de C#, utilizando la tecnología de Windows Presentation Foundation (WPF). Entre otros proyectos relacionados con las áreas tecnológicas antes mencionadas.<br><br>
        Sus intereses de investigación incluyen trabajar con redes de computadoras con un enfoque en ciberseguridad, estadísticas y análisis de datos para la identificación de tendencias,  algoritmos de inteligencia artificial así como la creación de interfaces de usuario atractivas, funcionales y amigables.<br><br>
      </p>



    </section>


  </section>





  </body>
</html>
